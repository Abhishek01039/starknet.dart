// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'get_block.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

GetBlockResponse _$GetBlockResponseFromJson(Map<String, dynamic> json) {
  return _GetBlockResponse.fromJson(json);
}

/// @nodoc
mixin _$GetBlockResponse {
  int get blockNumber => throw _privateConstructorUsedError;
  String get blockHash => throw _privateConstructorUsedError;
  List<TransactionReceipt> get transactionReceipts =>
      throw _privateConstructorUsedError;
  String get stateRoot => throw _privateConstructorUsedError;
  String get gasPrice => throw _privateConstructorUsedError;
  String get parentBlockHash => throw _privateConstructorUsedError;
  List<Transaction> get transactions => throw _privateConstructorUsedError;
  String get status => throw _privateConstructorUsedError;
  int get timestamp => throw _privateConstructorUsedError;
  String get sequencerAddress => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GetBlockResponseCopyWith<GetBlockResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GetBlockResponseCopyWith<$Res> {
  factory $GetBlockResponseCopyWith(
          GetBlockResponse value, $Res Function(GetBlockResponse) then) =
      _$GetBlockResponseCopyWithImpl<$Res>;
  $Res call(
      {int blockNumber,
      String blockHash,
      List<TransactionReceipt> transactionReceipts,
      String stateRoot,
      String gasPrice,
      String parentBlockHash,
      List<Transaction> transactions,
      String status,
      int timestamp,
      String sequencerAddress});
}

/// @nodoc
class _$GetBlockResponseCopyWithImpl<$Res>
    implements $GetBlockResponseCopyWith<$Res> {
  _$GetBlockResponseCopyWithImpl(this._value, this._then);

  final GetBlockResponse _value;
  // ignore: unused_field
  final $Res Function(GetBlockResponse) _then;

  @override
  $Res call({
    Object? blockNumber = freezed,
    Object? blockHash = freezed,
    Object? transactionReceipts = freezed,
    Object? stateRoot = freezed,
    Object? gasPrice = freezed,
    Object? parentBlockHash = freezed,
    Object? transactions = freezed,
    Object? status = freezed,
    Object? timestamp = freezed,
    Object? sequencerAddress = freezed,
  }) {
    return _then(_value.copyWith(
      blockNumber: blockNumber == freezed
          ? _value.blockNumber
          : blockNumber // ignore: cast_nullable_to_non_nullable
              as int,
      blockHash: blockHash == freezed
          ? _value.blockHash
          : blockHash // ignore: cast_nullable_to_non_nullable
              as String,
      transactionReceipts: transactionReceipts == freezed
          ? _value.transactionReceipts
          : transactionReceipts // ignore: cast_nullable_to_non_nullable
              as List<TransactionReceipt>,
      stateRoot: stateRoot == freezed
          ? _value.stateRoot
          : stateRoot // ignore: cast_nullable_to_non_nullable
              as String,
      gasPrice: gasPrice == freezed
          ? _value.gasPrice
          : gasPrice // ignore: cast_nullable_to_non_nullable
              as String,
      parentBlockHash: parentBlockHash == freezed
          ? _value.parentBlockHash
          : parentBlockHash // ignore: cast_nullable_to_non_nullable
              as String,
      transactions: transactions == freezed
          ? _value.transactions
          : transactions // ignore: cast_nullable_to_non_nullable
              as List<Transaction>,
      status: status == freezed
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
      timestamp: timestamp == freezed
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as int,
      sequencerAddress: sequencerAddress == freezed
          ? _value.sequencerAddress
          : sequencerAddress // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_GetBlockResponseCopyWith<$Res>
    implements $GetBlockResponseCopyWith<$Res> {
  factory _$$_GetBlockResponseCopyWith(
          _$_GetBlockResponse value, $Res Function(_$_GetBlockResponse) then) =
      __$$_GetBlockResponseCopyWithImpl<$Res>;
  @override
  $Res call(
      {int blockNumber,
      String blockHash,
      List<TransactionReceipt> transactionReceipts,
      String stateRoot,
      String gasPrice,
      String parentBlockHash,
      List<Transaction> transactions,
      String status,
      int timestamp,
      String sequencerAddress});
}

/// @nodoc
class __$$_GetBlockResponseCopyWithImpl<$Res>
    extends _$GetBlockResponseCopyWithImpl<$Res>
    implements _$$_GetBlockResponseCopyWith<$Res> {
  __$$_GetBlockResponseCopyWithImpl(
      _$_GetBlockResponse _value, $Res Function(_$_GetBlockResponse) _then)
      : super(_value, (v) => _then(v as _$_GetBlockResponse));

  @override
  _$_GetBlockResponse get _value => super._value as _$_GetBlockResponse;

  @override
  $Res call({
    Object? blockNumber = freezed,
    Object? blockHash = freezed,
    Object? transactionReceipts = freezed,
    Object? stateRoot = freezed,
    Object? gasPrice = freezed,
    Object? parentBlockHash = freezed,
    Object? transactions = freezed,
    Object? status = freezed,
    Object? timestamp = freezed,
    Object? sequencerAddress = freezed,
  }) {
    return _then(_$_GetBlockResponse(
      blockNumber: blockNumber == freezed
          ? _value.blockNumber
          : blockNumber // ignore: cast_nullable_to_non_nullable
              as int,
      blockHash: blockHash == freezed
          ? _value.blockHash
          : blockHash // ignore: cast_nullable_to_non_nullable
              as String,
      transactionReceipts: transactionReceipts == freezed
          ? _value._transactionReceipts
          : transactionReceipts // ignore: cast_nullable_to_non_nullable
              as List<TransactionReceipt>,
      stateRoot: stateRoot == freezed
          ? _value.stateRoot
          : stateRoot // ignore: cast_nullable_to_non_nullable
              as String,
      gasPrice: gasPrice == freezed
          ? _value.gasPrice
          : gasPrice // ignore: cast_nullable_to_non_nullable
              as String,
      parentBlockHash: parentBlockHash == freezed
          ? _value.parentBlockHash
          : parentBlockHash // ignore: cast_nullable_to_non_nullable
              as String,
      transactions: transactions == freezed
          ? _value._transactions
          : transactions // ignore: cast_nullable_to_non_nullable
              as List<Transaction>,
      status: status == freezed
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
      timestamp: timestamp == freezed
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as int,
      sequencerAddress: sequencerAddress == freezed
          ? _value.sequencerAddress
          : sequencerAddress // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_GetBlockResponse implements _GetBlockResponse {
  const _$_GetBlockResponse(
      {required this.blockNumber,
      required this.blockHash,
      required final List<TransactionReceipt> transactionReceipts,
      required this.stateRoot,
      required this.gasPrice,
      required this.parentBlockHash,
      required final List<Transaction> transactions,
      required this.status,
      required this.timestamp,
      required this.sequencerAddress})
      : _transactionReceipts = transactionReceipts,
        _transactions = transactions;

  factory _$_GetBlockResponse.fromJson(Map<String, dynamic> json) =>
      _$$_GetBlockResponseFromJson(json);

  @override
  final int blockNumber;
  @override
  final String blockHash;
  final List<TransactionReceipt> _transactionReceipts;
  @override
  List<TransactionReceipt> get transactionReceipts {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_transactionReceipts);
  }

  @override
  final String stateRoot;
  @override
  final String gasPrice;
  @override
  final String parentBlockHash;
  final List<Transaction> _transactions;
  @override
  List<Transaction> get transactions {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_transactions);
  }

  @override
  final String status;
  @override
  final int timestamp;
  @override
  final String sequencerAddress;

  @override
  String toString() {
    return 'GetBlockResponse(blockNumber: $blockNumber, blockHash: $blockHash, transactionReceipts: $transactionReceipts, stateRoot: $stateRoot, gasPrice: $gasPrice, parentBlockHash: $parentBlockHash, transactions: $transactions, status: $status, timestamp: $timestamp, sequencerAddress: $sequencerAddress)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_GetBlockResponse &&
            const DeepCollectionEquality()
                .equals(other.blockNumber, blockNumber) &&
            const DeepCollectionEquality().equals(other.blockHash, blockHash) &&
            const DeepCollectionEquality()
                .equals(other._transactionReceipts, _transactionReceipts) &&
            const DeepCollectionEquality().equals(other.stateRoot, stateRoot) &&
            const DeepCollectionEquality().equals(other.gasPrice, gasPrice) &&
            const DeepCollectionEquality()
                .equals(other.parentBlockHash, parentBlockHash) &&
            const DeepCollectionEquality()
                .equals(other._transactions, _transactions) &&
            const DeepCollectionEquality().equals(other.status, status) &&
            const DeepCollectionEquality().equals(other.timestamp, timestamp) &&
            const DeepCollectionEquality()
                .equals(other.sequencerAddress, sequencerAddress));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(blockNumber),
      const DeepCollectionEquality().hash(blockHash),
      const DeepCollectionEquality().hash(_transactionReceipts),
      const DeepCollectionEquality().hash(stateRoot),
      const DeepCollectionEquality().hash(gasPrice),
      const DeepCollectionEquality().hash(parentBlockHash),
      const DeepCollectionEquality().hash(_transactions),
      const DeepCollectionEquality().hash(status),
      const DeepCollectionEquality().hash(timestamp),
      const DeepCollectionEquality().hash(sequencerAddress));

  @JsonKey(ignore: true)
  @override
  _$$_GetBlockResponseCopyWith<_$_GetBlockResponse> get copyWith =>
      __$$_GetBlockResponseCopyWithImpl<_$_GetBlockResponse>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_GetBlockResponseToJson(this);
  }
}

abstract class _GetBlockResponse implements GetBlockResponse {
  const factory _GetBlockResponse(
      {required final int blockNumber,
      required final String blockHash,
      required final List<TransactionReceipt> transactionReceipts,
      required final String stateRoot,
      required final String gasPrice,
      required final String parentBlockHash,
      required final List<Transaction> transactions,
      required final String status,
      required final int timestamp,
      required final String sequencerAddress}) = _$_GetBlockResponse;

  factory _GetBlockResponse.fromJson(Map<String, dynamic> json) =
      _$_GetBlockResponse.fromJson;

  @override
  int get blockNumber => throw _privateConstructorUsedError;
  @override
  String get blockHash => throw _privateConstructorUsedError;
  @override
  List<TransactionReceipt> get transactionReceipts =>
      throw _privateConstructorUsedError;
  @override
  String get stateRoot => throw _privateConstructorUsedError;
  @override
  String get gasPrice => throw _privateConstructorUsedError;
  @override
  String get parentBlockHash => throw _privateConstructorUsedError;
  @override
  List<Transaction> get transactions => throw _privateConstructorUsedError;
  @override
  String get status => throw _privateConstructorUsedError;
  @override
  int get timestamp => throw _privateConstructorUsedError;
  @override
  String get sequencerAddress => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_GetBlockResponseCopyWith<_$_GetBlockResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

TransactionReceipt _$TransactionReceiptFromJson(Map<String, dynamic> json) {
  return _TransactionReceipt.fromJson(json);
}

/// @nodoc
mixin _$TransactionReceipt {
  String get transactionHash => throw _privateConstructorUsedError;
  int get transactionIndex => throw _privateConstructorUsedError;
  String get actualFee => throw _privateConstructorUsedError;
  List<String> get events => throw _privateConstructorUsedError;
  List<String> get l2ToL1Messages => throw _privateConstructorUsedError;
  ExecutionResources get executionResources =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TransactionReceiptCopyWith<TransactionReceipt> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TransactionReceiptCopyWith<$Res> {
  factory $TransactionReceiptCopyWith(
          TransactionReceipt value, $Res Function(TransactionReceipt) then) =
      _$TransactionReceiptCopyWithImpl<$Res>;
  $Res call(
      {String transactionHash,
      int transactionIndex,
      String actualFee,
      List<String> events,
      List<String> l2ToL1Messages,
      ExecutionResources executionResources});

  $ExecutionResourcesCopyWith<$Res> get executionResources;
}

/// @nodoc
class _$TransactionReceiptCopyWithImpl<$Res>
    implements $TransactionReceiptCopyWith<$Res> {
  _$TransactionReceiptCopyWithImpl(this._value, this._then);

  final TransactionReceipt _value;
  // ignore: unused_field
  final $Res Function(TransactionReceipt) _then;

  @override
  $Res call({
    Object? transactionHash = freezed,
    Object? transactionIndex = freezed,
    Object? actualFee = freezed,
    Object? events = freezed,
    Object? l2ToL1Messages = freezed,
    Object? executionResources = freezed,
  }) {
    return _then(_value.copyWith(
      transactionHash: transactionHash == freezed
          ? _value.transactionHash
          : transactionHash // ignore: cast_nullable_to_non_nullable
              as String,
      transactionIndex: transactionIndex == freezed
          ? _value.transactionIndex
          : transactionIndex // ignore: cast_nullable_to_non_nullable
              as int,
      actualFee: actualFee == freezed
          ? _value.actualFee
          : actualFee // ignore: cast_nullable_to_non_nullable
              as String,
      events: events == freezed
          ? _value.events
          : events // ignore: cast_nullable_to_non_nullable
              as List<String>,
      l2ToL1Messages: l2ToL1Messages == freezed
          ? _value.l2ToL1Messages
          : l2ToL1Messages // ignore: cast_nullable_to_non_nullable
              as List<String>,
      executionResources: executionResources == freezed
          ? _value.executionResources
          : executionResources // ignore: cast_nullable_to_non_nullable
              as ExecutionResources,
    ));
  }

  @override
  $ExecutionResourcesCopyWith<$Res> get executionResources {
    return $ExecutionResourcesCopyWith<$Res>(_value.executionResources,
        (value) {
      return _then(_value.copyWith(executionResources: value));
    });
  }
}

/// @nodoc
abstract class _$$_TransactionReceiptCopyWith<$Res>
    implements $TransactionReceiptCopyWith<$Res> {
  factory _$$_TransactionReceiptCopyWith(_$_TransactionReceipt value,
          $Res Function(_$_TransactionReceipt) then) =
      __$$_TransactionReceiptCopyWithImpl<$Res>;
  @override
  $Res call(
      {String transactionHash,
      int transactionIndex,
      String actualFee,
      List<String> events,
      List<String> l2ToL1Messages,
      ExecutionResources executionResources});

  @override
  $ExecutionResourcesCopyWith<$Res> get executionResources;
}

/// @nodoc
class __$$_TransactionReceiptCopyWithImpl<$Res>
    extends _$TransactionReceiptCopyWithImpl<$Res>
    implements _$$_TransactionReceiptCopyWith<$Res> {
  __$$_TransactionReceiptCopyWithImpl(
      _$_TransactionReceipt _value, $Res Function(_$_TransactionReceipt) _then)
      : super(_value, (v) => _then(v as _$_TransactionReceipt));

  @override
  _$_TransactionReceipt get _value => super._value as _$_TransactionReceipt;

  @override
  $Res call({
    Object? transactionHash = freezed,
    Object? transactionIndex = freezed,
    Object? actualFee = freezed,
    Object? events = freezed,
    Object? l2ToL1Messages = freezed,
    Object? executionResources = freezed,
  }) {
    return _then(_$_TransactionReceipt(
      transactionHash: transactionHash == freezed
          ? _value.transactionHash
          : transactionHash // ignore: cast_nullable_to_non_nullable
              as String,
      transactionIndex: transactionIndex == freezed
          ? _value.transactionIndex
          : transactionIndex // ignore: cast_nullable_to_non_nullable
              as int,
      actualFee: actualFee == freezed
          ? _value.actualFee
          : actualFee // ignore: cast_nullable_to_non_nullable
              as String,
      events: events == freezed
          ? _value._events
          : events // ignore: cast_nullable_to_non_nullable
              as List<String>,
      l2ToL1Messages: l2ToL1Messages == freezed
          ? _value._l2ToL1Messages
          : l2ToL1Messages // ignore: cast_nullable_to_non_nullable
              as List<String>,
      executionResources: executionResources == freezed
          ? _value.executionResources
          : executionResources // ignore: cast_nullable_to_non_nullable
              as ExecutionResources,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TransactionReceipt implements _TransactionReceipt {
  const _$_TransactionReceipt(
      {required this.transactionHash,
      required this.transactionIndex,
      required this.actualFee,
      required final List<String> events,
      required final List<String> l2ToL1Messages,
      required this.executionResources})
      : _events = events,
        _l2ToL1Messages = l2ToL1Messages;

  factory _$_TransactionReceipt.fromJson(Map<String, dynamic> json) =>
      _$$_TransactionReceiptFromJson(json);

  @override
  final String transactionHash;
  @override
  final int transactionIndex;
  @override
  final String actualFee;
  final List<String> _events;
  @override
  List<String> get events {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_events);
  }

  final List<String> _l2ToL1Messages;
  @override
  List<String> get l2ToL1Messages {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_l2ToL1Messages);
  }

  @override
  final ExecutionResources executionResources;

  @override
  String toString() {
    return 'TransactionReceipt(transactionHash: $transactionHash, transactionIndex: $transactionIndex, actualFee: $actualFee, events: $events, l2ToL1Messages: $l2ToL1Messages, executionResources: $executionResources)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TransactionReceipt &&
            const DeepCollectionEquality()
                .equals(other.transactionHash, transactionHash) &&
            const DeepCollectionEquality()
                .equals(other.transactionIndex, transactionIndex) &&
            const DeepCollectionEquality().equals(other.actualFee, actualFee) &&
            const DeepCollectionEquality().equals(other._events, _events) &&
            const DeepCollectionEquality()
                .equals(other._l2ToL1Messages, _l2ToL1Messages) &&
            const DeepCollectionEquality()
                .equals(other.executionResources, executionResources));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(transactionHash),
      const DeepCollectionEquality().hash(transactionIndex),
      const DeepCollectionEquality().hash(actualFee),
      const DeepCollectionEquality().hash(_events),
      const DeepCollectionEquality().hash(_l2ToL1Messages),
      const DeepCollectionEquality().hash(executionResources));

  @JsonKey(ignore: true)
  @override
  _$$_TransactionReceiptCopyWith<_$_TransactionReceipt> get copyWith =>
      __$$_TransactionReceiptCopyWithImpl<_$_TransactionReceipt>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TransactionReceiptToJson(this);
  }
}

abstract class _TransactionReceipt implements TransactionReceipt {
  const factory _TransactionReceipt(
          {required final String transactionHash,
          required final int transactionIndex,
          required final String actualFee,
          required final List<String> events,
          required final List<String> l2ToL1Messages,
          required final ExecutionResources executionResources}) =
      _$_TransactionReceipt;

  factory _TransactionReceipt.fromJson(Map<String, dynamic> json) =
      _$_TransactionReceipt.fromJson;

  @override
  String get transactionHash => throw _privateConstructorUsedError;
  @override
  int get transactionIndex => throw _privateConstructorUsedError;
  @override
  String get actualFee => throw _privateConstructorUsedError;
  @override
  List<String> get events => throw _privateConstructorUsedError;
  @override
  List<String> get l2ToL1Messages => throw _privateConstructorUsedError;
  @override
  ExecutionResources get executionResources =>
      throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_TransactionReceiptCopyWith<_$_TransactionReceipt> get copyWith =>
      throw _privateConstructorUsedError;
}

Transaction _$TransactionFromJson(Map<String, dynamic> json) {
  return _Transaction.fromJson(json);
}

/// @nodoc
mixin _$Transaction {
  String get transactionHash => throw _privateConstructorUsedError;
  List<String> get constructorCalldata => throw _privateConstructorUsedError;
  String get contractAddress => throw _privateConstructorUsedError;
  String get contractAddressSalt => throw _privateConstructorUsedError;
  String get type => throw _privateConstructorUsedError;
  String get classHash => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TransactionCopyWith<Transaction> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TransactionCopyWith<$Res> {
  factory $TransactionCopyWith(
          Transaction value, $Res Function(Transaction) then) =
      _$TransactionCopyWithImpl<$Res>;
  $Res call(
      {String transactionHash,
      List<String> constructorCalldata,
      String contractAddress,
      String contractAddressSalt,
      String type,
      String classHash});
}

/// @nodoc
class _$TransactionCopyWithImpl<$Res> implements $TransactionCopyWith<$Res> {
  _$TransactionCopyWithImpl(this._value, this._then);

  final Transaction _value;
  // ignore: unused_field
  final $Res Function(Transaction) _then;

  @override
  $Res call({
    Object? transactionHash = freezed,
    Object? constructorCalldata = freezed,
    Object? contractAddress = freezed,
    Object? contractAddressSalt = freezed,
    Object? type = freezed,
    Object? classHash = freezed,
  }) {
    return _then(_value.copyWith(
      transactionHash: transactionHash == freezed
          ? _value.transactionHash
          : transactionHash // ignore: cast_nullable_to_non_nullable
              as String,
      constructorCalldata: constructorCalldata == freezed
          ? _value.constructorCalldata
          : constructorCalldata // ignore: cast_nullable_to_non_nullable
              as List<String>,
      contractAddress: contractAddress == freezed
          ? _value.contractAddress
          : contractAddress // ignore: cast_nullable_to_non_nullable
              as String,
      contractAddressSalt: contractAddressSalt == freezed
          ? _value.contractAddressSalt
          : contractAddressSalt // ignore: cast_nullable_to_non_nullable
              as String,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      classHash: classHash == freezed
          ? _value.classHash
          : classHash // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_TransactionCopyWith<$Res>
    implements $TransactionCopyWith<$Res> {
  factory _$$_TransactionCopyWith(
          _$_Transaction value, $Res Function(_$_Transaction) then) =
      __$$_TransactionCopyWithImpl<$Res>;
  @override
  $Res call(
      {String transactionHash,
      List<String> constructorCalldata,
      String contractAddress,
      String contractAddressSalt,
      String type,
      String classHash});
}

/// @nodoc
class __$$_TransactionCopyWithImpl<$Res> extends _$TransactionCopyWithImpl<$Res>
    implements _$$_TransactionCopyWith<$Res> {
  __$$_TransactionCopyWithImpl(
      _$_Transaction _value, $Res Function(_$_Transaction) _then)
      : super(_value, (v) => _then(v as _$_Transaction));

  @override
  _$_Transaction get _value => super._value as _$_Transaction;

  @override
  $Res call({
    Object? transactionHash = freezed,
    Object? constructorCalldata = freezed,
    Object? contractAddress = freezed,
    Object? contractAddressSalt = freezed,
    Object? type = freezed,
    Object? classHash = freezed,
  }) {
    return _then(_$_Transaction(
      transactionHash: transactionHash == freezed
          ? _value.transactionHash
          : transactionHash // ignore: cast_nullable_to_non_nullable
              as String,
      constructorCalldata: constructorCalldata == freezed
          ? _value._constructorCalldata
          : constructorCalldata // ignore: cast_nullable_to_non_nullable
              as List<String>,
      contractAddress: contractAddress == freezed
          ? _value.contractAddress
          : contractAddress // ignore: cast_nullable_to_non_nullable
              as String,
      contractAddressSalt: contractAddressSalt == freezed
          ? _value.contractAddressSalt
          : contractAddressSalt // ignore: cast_nullable_to_non_nullable
              as String,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      classHash: classHash == freezed
          ? _value.classHash
          : classHash // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Transaction implements _Transaction {
  const _$_Transaction(
      {required this.transactionHash,
      required final List<String> constructorCalldata,
      required this.contractAddress,
      required this.contractAddressSalt,
      required this.type,
      required this.classHash})
      : _constructorCalldata = constructorCalldata;

  factory _$_Transaction.fromJson(Map<String, dynamic> json) =>
      _$$_TransactionFromJson(json);

  @override
  final String transactionHash;
  final List<String> _constructorCalldata;
  @override
  List<String> get constructorCalldata {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_constructorCalldata);
  }

  @override
  final String contractAddress;
  @override
  final String contractAddressSalt;
  @override
  final String type;
  @override
  final String classHash;

  @override
  String toString() {
    return 'Transaction(transactionHash: $transactionHash, constructorCalldata: $constructorCalldata, contractAddress: $contractAddress, contractAddressSalt: $contractAddressSalt, type: $type, classHash: $classHash)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Transaction &&
            const DeepCollectionEquality()
                .equals(other.transactionHash, transactionHash) &&
            const DeepCollectionEquality()
                .equals(other._constructorCalldata, _constructorCalldata) &&
            const DeepCollectionEquality()
                .equals(other.contractAddress, contractAddress) &&
            const DeepCollectionEquality()
                .equals(other.contractAddressSalt, contractAddressSalt) &&
            const DeepCollectionEquality().equals(other.type, type) &&
            const DeepCollectionEquality().equals(other.classHash, classHash));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(transactionHash),
      const DeepCollectionEquality().hash(_constructorCalldata),
      const DeepCollectionEquality().hash(contractAddress),
      const DeepCollectionEquality().hash(contractAddressSalt),
      const DeepCollectionEquality().hash(type),
      const DeepCollectionEquality().hash(classHash));

  @JsonKey(ignore: true)
  @override
  _$$_TransactionCopyWith<_$_Transaction> get copyWith =>
      __$$_TransactionCopyWithImpl<_$_Transaction>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TransactionToJson(this);
  }
}

abstract class _Transaction implements Transaction {
  const factory _Transaction(
      {required final String transactionHash,
      required final List<String> constructorCalldata,
      required final String contractAddress,
      required final String contractAddressSalt,
      required final String type,
      required final String classHash}) = _$_Transaction;

  factory _Transaction.fromJson(Map<String, dynamic> json) =
      _$_Transaction.fromJson;

  @override
  String get transactionHash => throw _privateConstructorUsedError;
  @override
  List<String> get constructorCalldata => throw _privateConstructorUsedError;
  @override
  String get contractAddress => throw _privateConstructorUsedError;
  @override
  String get contractAddressSalt => throw _privateConstructorUsedError;
  @override
  String get type => throw _privateConstructorUsedError;
  @override
  String get classHash => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_TransactionCopyWith<_$_Transaction> get copyWith =>
      throw _privateConstructorUsedError;
}

ExecutionResources _$ExecutionResourcesFromJson(Map<String, dynamic> json) {
  return _ExecutionResources.fromJson(json);
}

/// @nodoc
mixin _$ExecutionResources {
  BuiltinInstanceCounter get builtinInstanceCounter =>
      throw _privateConstructorUsedError;
  int get nSteps => throw _privateConstructorUsedError;
  int get nMemoryHoles => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExecutionResourcesCopyWith<ExecutionResources> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExecutionResourcesCopyWith<$Res> {
  factory $ExecutionResourcesCopyWith(
          ExecutionResources value, $Res Function(ExecutionResources) then) =
      _$ExecutionResourcesCopyWithImpl<$Res>;
  $Res call(
      {BuiltinInstanceCounter builtinInstanceCounter,
      int nSteps,
      int nMemoryHoles});

  $BuiltinInstanceCounterCopyWith<$Res> get builtinInstanceCounter;
}

/// @nodoc
class _$ExecutionResourcesCopyWithImpl<$Res>
    implements $ExecutionResourcesCopyWith<$Res> {
  _$ExecutionResourcesCopyWithImpl(this._value, this._then);

  final ExecutionResources _value;
  // ignore: unused_field
  final $Res Function(ExecutionResources) _then;

  @override
  $Res call({
    Object? builtinInstanceCounter = freezed,
    Object? nSteps = freezed,
    Object? nMemoryHoles = freezed,
  }) {
    return _then(_value.copyWith(
      builtinInstanceCounter: builtinInstanceCounter == freezed
          ? _value.builtinInstanceCounter
          : builtinInstanceCounter // ignore: cast_nullable_to_non_nullable
              as BuiltinInstanceCounter,
      nSteps: nSteps == freezed
          ? _value.nSteps
          : nSteps // ignore: cast_nullable_to_non_nullable
              as int,
      nMemoryHoles: nMemoryHoles == freezed
          ? _value.nMemoryHoles
          : nMemoryHoles // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }

  @override
  $BuiltinInstanceCounterCopyWith<$Res> get builtinInstanceCounter {
    return $BuiltinInstanceCounterCopyWith<$Res>(_value.builtinInstanceCounter,
        (value) {
      return _then(_value.copyWith(builtinInstanceCounter: value));
    });
  }
}

/// @nodoc
abstract class _$$_ExecutionResourcesCopyWith<$Res>
    implements $ExecutionResourcesCopyWith<$Res> {
  factory _$$_ExecutionResourcesCopyWith(_$_ExecutionResources value,
          $Res Function(_$_ExecutionResources) then) =
      __$$_ExecutionResourcesCopyWithImpl<$Res>;
  @override
  $Res call(
      {BuiltinInstanceCounter builtinInstanceCounter,
      int nSteps,
      int nMemoryHoles});

  @override
  $BuiltinInstanceCounterCopyWith<$Res> get builtinInstanceCounter;
}

/// @nodoc
class __$$_ExecutionResourcesCopyWithImpl<$Res>
    extends _$ExecutionResourcesCopyWithImpl<$Res>
    implements _$$_ExecutionResourcesCopyWith<$Res> {
  __$$_ExecutionResourcesCopyWithImpl(
      _$_ExecutionResources _value, $Res Function(_$_ExecutionResources) _then)
      : super(_value, (v) => _then(v as _$_ExecutionResources));

  @override
  _$_ExecutionResources get _value => super._value as _$_ExecutionResources;

  @override
  $Res call({
    Object? builtinInstanceCounter = freezed,
    Object? nSteps = freezed,
    Object? nMemoryHoles = freezed,
  }) {
    return _then(_$_ExecutionResources(
      builtinInstanceCounter: builtinInstanceCounter == freezed
          ? _value.builtinInstanceCounter
          : builtinInstanceCounter // ignore: cast_nullable_to_non_nullable
              as BuiltinInstanceCounter,
      nSteps: nSteps == freezed
          ? _value.nSteps
          : nSteps // ignore: cast_nullable_to_non_nullable
              as int,
      nMemoryHoles: nMemoryHoles == freezed
          ? _value.nMemoryHoles
          : nMemoryHoles // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ExecutionResources implements _ExecutionResources {
  const _$_ExecutionResources(
      {required this.builtinInstanceCounter,
      required this.nSteps,
      required this.nMemoryHoles});

  factory _$_ExecutionResources.fromJson(Map<String, dynamic> json) =>
      _$$_ExecutionResourcesFromJson(json);

  @override
  final BuiltinInstanceCounter builtinInstanceCounter;
  @override
  final int nSteps;
  @override
  final int nMemoryHoles;

  @override
  String toString() {
    return 'ExecutionResources(builtinInstanceCounter: $builtinInstanceCounter, nSteps: $nSteps, nMemoryHoles: $nMemoryHoles)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ExecutionResources &&
            const DeepCollectionEquality()
                .equals(other.builtinInstanceCounter, builtinInstanceCounter) &&
            const DeepCollectionEquality().equals(other.nSteps, nSteps) &&
            const DeepCollectionEquality()
                .equals(other.nMemoryHoles, nMemoryHoles));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(builtinInstanceCounter),
      const DeepCollectionEquality().hash(nSteps),
      const DeepCollectionEquality().hash(nMemoryHoles));

  @JsonKey(ignore: true)
  @override
  _$$_ExecutionResourcesCopyWith<_$_ExecutionResources> get copyWith =>
      __$$_ExecutionResourcesCopyWithImpl<_$_ExecutionResources>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ExecutionResourcesToJson(this);
  }
}

abstract class _ExecutionResources implements ExecutionResources {
  const factory _ExecutionResources(
      {required final BuiltinInstanceCounter builtinInstanceCounter,
      required final int nSteps,
      required final int nMemoryHoles}) = _$_ExecutionResources;

  factory _ExecutionResources.fromJson(Map<String, dynamic> json) =
      _$_ExecutionResources.fromJson;

  @override
  BuiltinInstanceCounter get builtinInstanceCounter =>
      throw _privateConstructorUsedError;
  @override
  int get nSteps => throw _privateConstructorUsedError;
  @override
  int get nMemoryHoles => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_ExecutionResourcesCopyWith<_$_ExecutionResources> get copyWith =>
      throw _privateConstructorUsedError;
}

BuiltinInstanceCounter _$BuiltinInstanceCounterFromJson(
    Map<String, dynamic> json) {
  return _BuiltinInstanceCounter.fromJson(json);
}

/// @nodoc
mixin _$BuiltinInstanceCounter {
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BuiltinInstanceCounterCopyWith<$Res> {
  factory $BuiltinInstanceCounterCopyWith(BuiltinInstanceCounter value,
          $Res Function(BuiltinInstanceCounter) then) =
      _$BuiltinInstanceCounterCopyWithImpl<$Res>;
}

/// @nodoc
class _$BuiltinInstanceCounterCopyWithImpl<$Res>
    implements $BuiltinInstanceCounterCopyWith<$Res> {
  _$BuiltinInstanceCounterCopyWithImpl(this._value, this._then);

  final BuiltinInstanceCounter _value;
  // ignore: unused_field
  final $Res Function(BuiltinInstanceCounter) _then;
}

/// @nodoc
abstract class _$$_BuiltinInstanceCounterCopyWith<$Res> {
  factory _$$_BuiltinInstanceCounterCopyWith(_$_BuiltinInstanceCounter value,
          $Res Function(_$_BuiltinInstanceCounter) then) =
      __$$_BuiltinInstanceCounterCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_BuiltinInstanceCounterCopyWithImpl<$Res>
    extends _$BuiltinInstanceCounterCopyWithImpl<$Res>
    implements _$$_BuiltinInstanceCounterCopyWith<$Res> {
  __$$_BuiltinInstanceCounterCopyWithImpl(_$_BuiltinInstanceCounter _value,
      $Res Function(_$_BuiltinInstanceCounter) _then)
      : super(_value, (v) => _then(v as _$_BuiltinInstanceCounter));

  @override
  _$_BuiltinInstanceCounter get _value =>
      super._value as _$_BuiltinInstanceCounter;
}

/// @nodoc
@JsonSerializable()
class _$_BuiltinInstanceCounter implements _BuiltinInstanceCounter {
  const _$_BuiltinInstanceCounter();

  factory _$_BuiltinInstanceCounter.fromJson(Map<String, dynamic> json) =>
      _$$_BuiltinInstanceCounterFromJson(json);

  @override
  String toString() {
    return 'BuiltinInstanceCounter()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_BuiltinInstanceCounter);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  Map<String, dynamic> toJson() {
    return _$$_BuiltinInstanceCounterToJson(this);
  }
}

abstract class _BuiltinInstanceCounter implements BuiltinInstanceCounter {
  const factory _BuiltinInstanceCounter() = _$_BuiltinInstanceCounter;

  factory _BuiltinInstanceCounter.fromJson(Map<String, dynamic> json) =
      _$_BuiltinInstanceCounter.fromJson;
}
